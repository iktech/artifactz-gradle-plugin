/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package io.iktech.artifactz.gradle.plugin

import io.iktech.artifactz.gradle.plugin.actions.DependencyManagementApplier
import io.iktech.artifactz.gradle.plugin.actions.DependencyResolver
import io.iktech.artifactz.gradle.plugin.extensions.PublishArtifactExtension
import io.iktech.artifactz.gradle.plugin.extensions.PushArtifactExtension
import io.iktech.artifactz.gradle.plugin.tasks.PublishArtifactTask
import io.iktech.artifactz.gradle.plugin.tasks.PushArtifactTask
import org.gradle.api.Plugin
import org.gradle.api.Project
import org.slf4j.LoggerFactory

/**
 * The plugin expands incomplete java dependencies in all configurations. Incomplete dependency is the one without version,
 * i.e. when it looks like this `io.iktech.test:test-data` instead of `io.iktech.test:test-data:1.0.0`. The plugin detects
 * such dependencies and tries to find out if their version is registered in the artifactz.io service. If such artifact has
 * been found plugin will apply the version retrieved from the artifactz.io service.
 *
 * By default, it uses 'Development' stage to retrieve versions. If necessary, the stage could be overwritten using properties.
 */
class ArtifactzPlugin: Plugin<Project> {
    private val logger = LoggerFactory.getLogger(DependencyResolver::class.java)
    override fun apply(project: Project) {
        // Read the gradle properties that configure connection to the artifactz.io service
        logger.info("******* Applying ArtifactzPlugin")

        // By default, we use production instance of the artifactz.io service
        var serverUrl = project.properties["artifactzServerUrl"] as String?
        if (serverUrl == null) {
            serverUrl = "https://artifactor.artifactz.io"
        }

        // By default, we try to retrieve version details from the `Development' stage
        var stage = project.properties["artifactzStage"] as String?
        if (stage == null) {
            stage = "Development"
        }

        // API token is required
        val apiToken = project.properties["artifactzApiToken"] as String

        // Get proxy details if necessary
        val proxyUrl = project.properties["artifactzProxyUrl"] as String?
        val proxyUsername = project.properties["artifactzProxyUsername"] as String?
        val proxyPassword = project.properties["artifactzProxyPassword"] as String?

        val publishArtifactExtension = project.extensions.create("publishArtifact", PublishArtifactExtension::class.java)
        val pushArtifactExtension = project.extensions.create("pushArtifact", PushArtifactExtension::class.java)

        publishArtifactExtension.serverUrl = serverUrl
        pushArtifactExtension.serverUrl = serverUrl

        if (publishArtifactExtension.accessToken == null) {
            publishArtifactExtension.accessToken = apiToken
        }

        if (publishArtifactExtension.proxyUrl == null) {
            publishArtifactExtension.proxyUrl = proxyUrl
        }

        if (publishArtifactExtension.proxyUsername == null) {
            publishArtifactExtension.proxyUsername = proxyUsername
        }

        if (publishArtifactExtension.proxyPassword == null) {
            publishArtifactExtension.proxyPassword = proxyPassword
        }

        project.tasks.register("publishArtifact", PublishArtifactTask::class.java, publishArtifactExtension)

        if (pushArtifactExtension.accessToken == null) {
            pushArtifactExtension.accessToken = apiToken
        }

        if (pushArtifactExtension.proxyUrl == null) {
            pushArtifactExtension.proxyUrl = proxyUrl
        }

        if (pushArtifactExtension.proxyUsername == null) {
            pushArtifactExtension.proxyUsername = proxyUsername
        }

        if (pushArtifactExtension.proxyPassword == null) {
            pushArtifactExtension.proxyPassword = proxyPassword
        }

        project.tasks.register("pushArtifact", PushArtifactTask::class.java, pushArtifactExtension)

        project.configurations.all(DependencyManagementApplier(serverUrl, apiToken, proxyUrl, proxyUsername, proxyPassword, stage))
    }
}
